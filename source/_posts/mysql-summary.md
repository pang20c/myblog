---
title: mysql 知识点总结
date: 2017-07-26 23:57:39
tags:
- mysql
category:
- mysql
---

# 范式
* 第一范式，所有字段都是原子性不可再拆解的
* 第二范式，主键字段之外的字段都完全依赖主键，不能部分依赖主键
* 第三范式，字段对主键的依赖必须是直接依赖，不能是传递依赖

第二范式只有在组合主键的情况下才会出现，举例，订单条目表（订单id，商品id，商品数量，商品价格），订单id和商品id组合成为主键，但是商品价格只依赖于商品id，与订单id并没有直接的关系因此这样的表就不符合第二范式，商品价格属于冗余字段

第三范式标识虽然在主键确定后其他属性的值也确定了但是却不是直接确定的而是经过了一步或多不的跳转，即主键 确定了属性A 属性A 又确定了属性B，这种情况就是违反第三范式的，举例，商品表（商品id，商品名，商品价格，分类id，分类名）其中商品id是主键，虽然知道了商品id能确定分类名是什么，但其实不是直接确定的，而是经过 商品->分类->分类名这样跳了一步 因此这样的表不符合第三范式

# 隔离级别
* 未提交读
* 已提交读
* 可重复读
* 串行化

![](media/15010870833183.jpg)

- 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
- 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
- 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读
- 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

可重复读 是针对update来说的，即我每次同样select都得到同样的结果，只要我自己不更新，哪怕是别的事务更新了我看到的数据也不会有变化，通俗的说就是排除了外界的干扰。

幻读 是针对insert来说的，比如我原来的where条件是 where a>1 and a<5 查出来了3条数据 1，2，3，这时候在我第二次执行这个查询的间隙，有别人执行了插入操作把 4 个插入进来了 ，第二次查询的结果就变成了1，2，3，4 这时候就叫出现了幻读，给行加锁没法阻止幻读，要给行间隙也加锁。


# 锁
数据库采用两段锁协议，即将事务分为加锁阶段和解锁阶段。

* 在加锁阶段，读操作会申请共享锁(S锁)，写操作会申请排他锁（X锁），如果锁申请不成功则整个事务阻塞等待。
* 在解锁阶段事务开始释放锁，此时不能再重新的申请锁。


### 关于行锁

innodb的行锁，如果能利用到索引即在存储引擎层就能确定锁定的范围那么就会锁定指定的行，但是如果没有利用到所以那么存储引擎会先锁住整个表，然后返回给服务器层，服务器层再根据where条件通知存储引擎去释放没必要的锁。

### 不同隔离级别的锁
虽然有四个隔离级别但是 未提交读和串行化一般是不开启的，因此我们只关注`提交读`和`可重复读`即可。

在提交读级别（RC），读取数据是不加锁的，但是变动数据时要加锁，因为读没有加锁，所以会产生不可重复读和幻读。

在可重复读级别（RR），mysql 采用MVCC（多版本并发控制，可以看成一种乐观锁）来实现可重复读，来实现可重复读 和 解决幻读

在序列化这个级别，读加共享锁，写加排他锁。

## MVCC

innodb 会给每行数据添加两个隐藏的版本号，一个是创建版本号，一个是删除版本号，每一个事务都会有一个递增的版本号，行上面的两个版本号就是来自于事务。

- SELECT时，读取创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号（含义是找到自己事务开始时就已经创建，并且还没有被删除的数据）。
- INSERT时，保存当前事务版本号为行的创建版本号
- DELETE时，保存当前事务版本号为行的删除版本号（注意这一行数据还在，类似假删除）
- UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行（标记一个修改的时间点）

举例A事务的版本号是1，它先创建了一条id=99的数据，然后读取where id=99这条记录 那么他的隐含查询条件是 where id=99 and create_version <=1 and (delete_version = null or delete_version > =1)
这时候如果版本号是2的事务B修改数据1 那么id=99的数据就会出现两条，一条是create_version = 2 delete_version = null的最新数据 一条是create_version = 1 delete_version = 2的历史数据。

以上关于MVCC的解释是不准确的，但是只最容易理解的，详细的解释见 http://www.imooc.com/article/17290

## 常用查询函数

### 字符串函数

- select concat(file1,file2,file3); 链接字符串
- select left(file1,3);取file1的最左边三个字符
- select replace(file1,'aaa','bbb');字符串替换

### 时间函数
- select unix_timestamp('2017-08-03'); 返回时间戳
- select from_unixtime(1501689600);返回日期

## 数据库状态查看

- show engines 查看数据库支持的引擎
- show status 数据库统计信息
    -  `show status like 'Com_select'` 统计查询次数
    -  `show status like 'Com_select'` 统计查询次数
- show index from table1
    





